<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Mi Juego Multijugador</title>
  <style>
    body {
      	margin: 0;
	display: flex;
	background-color: #0000FF; }
    form {
      	text-align: center; }
    #gameCanvas {
	top: 0;
  	left: 0;
  	width: 100vw;
	position: absolute;
	display: none; }
    #hexagonGroup {
	top: 40;
  	left: 0;
  	width: 100vw;
  	height: 100vh;
	position: absolute;
      	display: none; }
    #bluePoint {
      display: none; /* Ocultar inicialmente */ }
  </style>
</head>
<body>

  <form id="nameForm">
    <label for="playerName">Introduce tu nombre:</label>
    <input type="text" id="playerName" name="playerName" required>
    <button type="button" id="submitButton">Aceptar</button>
  </form>

  <canvas id="gameCanvas" height="30"  style="background-color: #ff0000;"></canvas>
  <svg id="hexagonGroup" style="background-color: #ffffff;" ></svg>
  <circle id="bluePoint" cx="170" cy="170" r="8" fill="blue" />

  <script src="/socket.io/socket.io.js"></script>
    	  
  <script>
	  
// COMIENZA EL JUEGO !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// CLIENT /////////////////////////////////////////////////////
	  
document.addEventListener('DOMContentLoaded', function () {
	
const nameForm = document.getElementById('nameForm');
const gameCanvas = document.getElementById('gameCanvas');
const canvas = document.getElementById('gameCanvas');
const context = canvas.getContext('2d');
const socket = io();


// DESPUES DE INTRODUCIR EL NOMBRE !!!!!!!!!!!!!!!!!!!!!!!!!
	
document.getElementById('submitButton').addEventListener('click', function () {
	console.log('CLIENTE EJECUTADO');
	socket.on('connect_error', (error) => {
    	console.error('Error de conexión:', error);
	});
	
	const playerName = document.getElementById('playerName').value;
	console.log(`Nombre Cliente: ${playerName}`);	    

	//Ocultar el formulario y mostrar el canvas
	nameForm.style.display = 'none';
	gameCanvas.style.display = 'block';
	hexagonGroup.style.display = 'block';

	// ACTIVAR EL SERVIDOR
	socket.emit('playerNameEntered', playerName);


socket.on('allPlayersInfo', (allPlayers) => {



console.log('ACTUALIZANDO JUGADORES');

    // Actualizar la información de todos los jugadores
    players = allPlayers;
    // ... (otros códigos relacionados con la actualización de la interfaz gráfica)
});



});

//VARIABLES 
  let randomV2 = 0;	
  let connectedUsers = 0;
  let isMoving = false
  let FirstMove = true
  const hexagonAngle = 0.523598776; // 30 degrees in radians
  const players = {}; // Objeto para almacenar la información de los jugadores
  const hexagonGroup = document.getElementById('hexagonGroup');
  const bluePoint = {id: socket.id, name: '', x: 170,  y: 170,  color: 'blue', };

//CIRCULO AZUL DEFINIDO
const bluePointElement = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
    bluePointElement.setAttribute('id', bluePoint.id);
    bluePointElement.setAttribute('r', '8');
    bluePointElement.setAttribute('fill', bluePoint.color);
    bluePointElement.setAttribute('cx', bluePoint.x);
    bluePointElement.setAttribute('cy', bluePoint.y);

//TEXT NAME DEFINIDO
const textElement = document.createElementNS('http://www.w3.org/2000/svg', 'text');
  textElement.setAttribute('x', bluePoint.x);
  textElement.setAttribute('y', bluePoint.y - 8 - 5); 
  textElement.setAttribute('text-anchor', 'middle');
  textElement.setAttribute('fill', 'red');
  textElement.setAttribute('font-size', '12px');
  textElement.textContent = 'Hola';
	

//CLICK LISTENER HEAGONGROUP!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	
hexagonGroup.addEventListener('click', function (event) {
	console.log('HEXAGON GROUP LOG');
	const mouseX = event.clientX - hexagonGroup.getBoundingClientRect().left;
        const mouseY = event.clientY - hexagonGroup.getBoundingClientRect().top;
	
	moveBluePoint(mouseX, mouseY);

	if(FirstMove){		
	FirstMove = false;
	}
	
});

//ASIGN COLOR !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//////////////////////////////////////////////////////////////////////
	
socket.on('assignColor', function (playerName) {
	console.log('SOCKET ASSIGN COLOR');
	
    	const playerNameT = playerName.name;
    	
	console.log(`Assign Nombre: ${playerNameT}`);	



socket.emit('updatePlayersRequest');
	
	});

	//socket.emit('playerNameEntered', playerName);
	
		


//UPDATE PLAYERS !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//////////////////////////////////////////////////////////////////////
	
socket.on('updatePlayers', function (updatedPlayers) {

	console.log('SOCKET UPDATE PLAYERS');
	
//Iterar sobre el objeto de jugadores y actualizar la información
for (const playerId in updatedPlayers) {
const player = updatedPlayers[playerId];

//PLAYER ELEMENT 
const existingPlayerElement = document.getElementById(playerId);
if (existingPlayerElement) {
	existingPlayerElement.setAttribute('cx', player.x);
	existingPlayerElement.setAttribute('cy', player.y);


playerElement.setAttribute('r', 9 + sizeCalc * 10);


} else {		
	const playerElement = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
      	playerElement.setAttribute('id', playerId);

const sizeCalc = player.puntos * 0.1;


      	playerElement.setAttribute('r', 9);



      	playerElement.setAttribute('fill', player.color);
      	playerElement.setAttribute('cx', player.x);
      	playerElement.setAttribute('cy', player.y);
	hexagonGroup.appendChild(playerElement);
}

//TEXT ELEMENT
const existingTextElement = document.getElementById(playerId + '-name');
if (existingTextElement) {
    existingTextElement.setAttribute('x', player.x);
    existingTextElement.setAttribute('y', player.y - 8);
    existingTextElement.textContent = player.nombre + ' ('+ player.puntos + ')';
} else {
    const textElement2 = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    textElement2.setAttribute('id', playerId + '-name');
    textElement2.setAttribute('x', player.x);
    textElement2.setAttribute('y', player.y - 10);
    textElement2.setAttribute('text-anchor', 'middle');
    textElement2.setAttribute('fill', 'green');
    textElement2.setAttribute('font-size', '16px');
    textElement2.textContent = 
player.nombre + ' ('+ player.puntos + ')';

    hexagonGroup.appendChild(textElement2);
}

//LOGS		
console.log(`PLAYER: ${playerId}, ${player.x}, ${player.y}, ${player.nombre},${player.color}`);
console.log(`PLAYER POINTS: ${player.puntos}`);

    }
});



   
//socket.emit('greenCircleEaten');	



//ANIMATE BLUE POINT !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//////////////////////////////////////////////////////////////////////
	
socket.on('animateBluePoint', function (animationData) {
	console.log('SOCKET ANIMATE BLUE POINT');
	const playerId = animationData.playerId;
    	const data = animationData.data;
	const txt = animationData.playerName;
    	// Encuentra el círculo correspondiente al jugador
    	const playerElement = document.getElementById(playerId);
   	const textElement2 = document.getElementById(playerId + '-name');
  
	animateCircleLocally(playerElement, data.start, data.end);
	animateNameLocally(textElement2, data.start, data.end);
});	


//ANIMATE CIRCLE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//////////////////////////////////////////////////////////////////////
			  
function animateCircleLocally(circleElement, start, end) {
	console.log('ANIMATE CIRCLE LOCALLY');
	const duration = 100;
  	const startTime = performance.now();
	function update() {
    	const currentTime = performance.now();
    	const progress = Math.min((currentTime - startTime) / duration, 1);
	const newX = start.x + progress * (end.x - start.x);
    	const newY = start.y + progress * (end.y - start.y);
		
	circleElement.setAttribute('cx', newX);
   	circleElement.setAttribute('cy', newY);
		
    	if (progress < 1) {
      	requestAnimationFrame(update); } }
	requestAnimationFrame(update);
}


//ANIMATE TEXT NAME !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//////////////////////////////////////////////////////////////////////
	
function animateNameLocally(circleElement, start, end) {
	console.log('ANIMATE CIRCLE LOCALLY');
	const duration = 100;
  	const startTime = performance.now();
	function update() {
    	const currentTime = performance.now();
    	const progress = Math.min((currentTime - startTime) / duration, 1);
	const newX = start.x + progress * (end.x - start.x);
    	const newY = start.y + progress * (end.y - start.y);
	
	circleElement.setAttribute('x', newX);
   	circleElement.setAttribute('y', newY - 8);

    	if (progress < 1) {
      	requestAnimationFrame(update); } }
	requestAnimationFrame(update);
}

//CREATE HEXAGON PANAL
createHexagons();

//MOVE BLUE POINT !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//////////////////////////////////////////////////////////////////////	
	
function moveBluePoint( clickX, clickY ) {   

	//socket.emit('updatePlayers'); // Emitir un nuevo evento al servidor

	if (!isMoving) { 
	console.log('/////MOVE PLAYER//////')
  	isMoving = true  
	drawUserCount();
		
	/*const closestVertex = findClosestVertices(bluePointElement.getAttribute('cx'), bluePointElement.getAttribute('cy'));
	const destinationX = closestVertex.x;
        const destinationY = closestVertex.y;
	console.log(`ClosestVertex: (${closestVertex.x}, ${closestVertex.y})`);
	animateBluePoint(destinationX, destinationY, function() {
     	findClosestVertices(bluePointElement.getAttribute('cx'), bluePointElement.getAttribute('cy'));
        console.log('Mov finalizado'); 
	});
	*/
		
	const closestLine = findClosestLine(
        bluePointElement.getAttribute('cx'), bluePointElement.getAttribute('cy'));
	const destinationX = closestLine.x2;
        const destinationY = closestLine.y2;
		
	animateBluePoint(destinationX, destinationY, function() {
        findClosestVertices(bluePointElement.getAttribute('cx'), bluePointElement.getAttribute('cy'));
	console.log('Mov finalizado'); 
	});
		
	findClosestRedVertexToClick( clickX, clickY);
		
	}
  }


//ANIMATE BLUE POINT !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//////////////////////////////////////////////////////////////////////
	
function animateBluePoint(destinationX, destinationY) {
	const startX = parseFloat(bluePointElement.getAttribute('cx'));
    	const startY = parseFloat(bluePointElement.getAttribute('cy'));
	console.log(`startX: ${startX}`);
 	console.log(`startY: ${startY}`);
	const startTime = performance.now();
    	const duration = 100; // 1 segundo
	function update() {
        const currentTime = performance.now();
        const elapsed = currentTime - startTime;
        const progress = Math.min(elapsed / duration, 1);
        const newX = startX + progress * (destinationX - startX);
        const newY = startY + progress * (destinationY - startY);
		
    	bluePointElement.setAttribute('cx', newX);
    	bluePointElement.setAttribute('cy', newY);
		
        if (progress < 1) {
        requestAnimationFrame(update);
        } else {
        
	// Animación completada, emitir datos al servidor
	socket.emit('animationData', { start: { x: startX, y: startY }, end: { x: newX, y: newY } });


	findClosestVertices(bluePointElement.getAttribute('cx'), bluePointElement.getAttribute('cy'));
		
	console.log('Mov finalizado');
	isMoving = false

// Supongamos que newPosition es un objeto con las nuevas coordenadas
const newPosition = { x:  newX , y: newY };
socket.emit('updatePosition', newPosition);

		          //  detectarColisiones();

		const playerElement = document.getElementById('nombreDeTuElementoJugador');
detectarColisiones(bluePointElement);

	}
    	}
	requestAnimationFrame(update);
}



//FIND CLOSEST RED VERTEX !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//////////////////////////////////////////////////////////////////////	
	
function findClosestRedVertexToClick(x, y) {
    	let closestVertex = null;
    	let minDistance = Infinity;
    	redVerticesArray.forEach((redVertex) => {
        const x1 = redVertex.x;
        const y1 = redVertex.y;
        const distance = pointToPointDistance2(x, y, x1, y1);
        if (distance < minDistance) {
        minDistance = distance;
        closestVertex = { x: x1, y: y1 };
        }
    	});
    	if (closestVertex) {
    	//bluePoint.setAttribute('cx',  closestVertex.x );
    	//bluePoint.setAttribute('cy',  closestVertex.y  );          
	animateBluePoint(closestVertex.x, closestVertex.y, function() { 
	findClosestVertices(bluePointElement.getAttribute('cx'), bluePointElement.getAttribute('cy'));
 	console.log('La animación ha terminado');
	});
    	} else {
        console.log(`No se encontró vértice rojo cercano a las coordenadas (${x}, ${y}).`);
    	}
    	return closestVertex;
}
	

//FIND AND DRAW RED VERTEX !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//////////////////////////////////////////////////////////////////////
	
let redVerticesArray = [];
function findClosestVertices(x, y) {
    	const hexagons = document.querySelectorAll('#hexagonGroup polygon');
    	let svg = document.querySelector('svg');
    	let nearbyVertices = [];
    	// Eliminar los puntos rojos existentes
    	redVerticesArray.forEach((redVertex) => {
        const existingRedDot = document.querySelector
        (`circle[fill="red"][cx="${redVertex.x}"][cy="${redVertex.y}"]`);
        if (existingRedDot) {
        svg.removeChild(existingRedDot);
        }
    	});
    	// Limpiar el arreglo de coordenadas de los vértices rojos
    	redVerticesArray = [];
	hexagons.forEach((hexagon) => {
        const points = hexagon.getAttribute('points').split(' ');
        // Iteramos sobre los vértices del hexágono
        for (let i = 0; i < points.length; i++) {
        const [x1, y1] = points[i].split(',').map(Number);
	// Calculamos la distancia entre el punto azul y el vértice
        const distance = pointToPointDistance2(x, y, x1, y1);
	// Marcamos el vértice si está dentro del radio de 50 pixeles alrededor del punto azul
        if (distance < 60) {
        nearbyVertices.push({ x: x1, y: y1 });
	// Almacenamos las coordenadas del vértice rojo
        redVerticesArray.push({ x: x1, y: y1 });
	// Dibujamos un círculo rojo en el vértice
        const redDot = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        redDot.setAttribute('cx', x1);
        redDot.setAttribute('cy', y1);
        redDot.setAttribute('r', '3');
        redDot.setAttribute('fill', 'red');
	svg.appendChild(redDot);
	// Mostramos las coordenadas en la consola
        //console.log(`Vértice (${x1}, ${y1}) marcado con círculo rojo.`);
        }
        }
    	});
    	// Encontramos el vértice rojo más cercano al clic
    	const clickX = x;
    	const clickY = y;
    	let closestVertex = null;
    	let minDistance = Infinity;
    	redVerticesArray.forEach((redVertex) => {
        const x1 = redVertex.x;
        const y1 = redVertex.y;
	const distance = pointToPointDistance2(clickX, clickY, x1, y1);
        if (distance < minDistance) {
        minDistance = distance;
        closestVertex = { x: x1, y: y1 };
	}
    	});
	if (closestVertex) {
        //console.log(`Vértice rojo más cercano al clic: 
        //(${closestVertex.x}, ${closestVertex.y})`);
        } else {
        console.log('No se encontraron vértices rojos cercanos');
	}
    	return nearbyVertices;
}

//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//////////////////////////////////////////////////////////////////////	
//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//////////////////////////////////////////////////////////////////////	
//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//////////////////////////////////////////////////////////////////////	
//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//////////////////////////////////////////////////////////////////////		
	
//POINT TO DISTANCE//////////////////////////////
/////////////////////////////////////////////////
	
function pointToPointDistance2(x1, y1, x2, y2) {
    	const dx = x1 - x2;
    	const dy = y1 - y2;
    	return Math.sqrt(dx * dx + dy * dy);
}

//CREATE HEXAGONS///////////////////////////
///////////////////////////////////////////////// 
function createHexagons(callback) {



//const randomValues = getRandomValues(1, 500, 30);

//console.log(randomValues);



randomV2 = printRandomValue(1, 500);

console.log(randomV2);


    const hexagonSize = 50;
    const numRows = 20;
    const numCols = 40;
    const hexWidth = hexagonSize * Math.sqrt(3);
    const hexHeight = hexagonSize * Math.sqrt(3);

    for (let row = 0; row < numRows; row++) {
      for (let col = 0; col < numCols; col++) {
        const x = col * (hexWidth * 0.87);
        const y = row * hexHeight + (col % 2 === 1 ? hexHeight / 2 : 0);
        const hexagon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
        hexagon.setAttribute('points', getHexagonPoints(x, y, hexagonSize));
        hexagon.setAttribute('fill', 'none');
        hexagon.setAttribute('stroke', 'gray');
        hexagon.setAttribute('stroke-width', '2');
        hexagon.addEventListener('click', function () {
          // Agregar el manejo de clic en hexágono aquí si es necesario
        });
        hexagonGroup.appendChild(hexagon);






      }
    }



if (callback) {
        callback();
    }

  }


createHexagons(function() {
    console.log("createHexagons has finished executing.");


drawGreenCirclesOnRandomPoints();

	
});



//GET HEXAGON POINTS///////////////////////////
///////////////////////////////////////////////// 


  function getHexagonPoints(x, y, size) {





	console.log('Hexagon Points');
    	const points = [];
    	for (let i = 0; i < 6; i++) {
      		const angle = (2 * Math.PI / 6) * i;
      		const pointX = x + size * Math.cos(angle);
      		const pointY = y + size * Math.sin(angle);
      //		points.push(`${pointX},${pointY}`);

///////////


const coordinate = `${pointX},${pointY}`;
    
//console.log(`Coordenada: (${coordinate})`); 

// Imprime la coordenada en consola
   
points.push(coordinate);


if(randomV2 === i)
{

//console.log(`Coordenada: (    ${pointX},${pointY}  )`);
}


///////////

    	}
    	return points.join(' ');
  }






function getRandomValues(min, max, count) {
  const values = [];

  for (let i = 0; i < count; i++) {
    const randomValue = Math.floor(Math.random() * (max - min + 1)) + min;
    values.push(randomValue);
  }

  return values;
}




//CONNECTED USERS////////////////////////////////
///////////////////////////////////////////////// 
//SOCKET.ON SIGNIFICA QUE ESTA ESCUCHANDO AL SERVIDOR. Son datos que vienen del servidor.
  socket.on('userCount', function (count) {
    connectedUsers = count;
    drawUserCount(); // Llamar a la función para actualizar el texto en el canvas
  });
  function drawUserCount() {
    context.fillStyle = 'black';
    context.font = '16px Arial';
    context.fillText(`Usuarios conectados: ${connectedUsers}`, 10, 5);
  }

		
//END CODE DOM///////////////////////////////////
///////////////////////////////////////////////// 

	//FIND CLOSEST LINE//////////////////////////////
    /////////////////////////////////////////////////
    
	function findClosestLine(x, y) {

    //console.log('1. Coordenadas Azul:', 
  //  bluePoint.getAttribute('cx'), bluePoint.getAttribute('cy'));
   
      const lines = document.querySelectorAll('#hexagonGroup polygon');
      let closestLine = null;
      let minDistance = Infinity;

      lines.forEach((hexagon) => {
        const points = hexagon.getAttribute('points').split(' ');
        for (let i = 0; i < points.length; i++) {
          const [x1, y1] = points[i].split(',').map(Number);
          const [x2, y2] = points[(i + 1) % points.length].split(',').map(Number);

          const distance = pointToLineDistance(x, y, x1, y1, x2, y2);
          if (distance < minDistance) {
     
            minDistance = distance;
            closestLine = { x1, y1, x2, y2 };
          }
        }
      });

      return closestLine;
    }
   
    //POINT TO LINE DISTANCE//////////////////////////
    /////////////////////////////////////////////////

    function pointToLineDistance(x, y, x1, y1, x2, y2) {
   
      const A = x - x1;
      const B = y - y1;
      const C = x2 - x1;
      const D = y2 - y1;

      const dot = A * C + B * D;
      const len_sq = C * C + D * D;
      const param = dot / len_sq;

      let xx, yy;

      if (param < 0 || (x1 === x2 && y1 === y2)) {
        xx = x1;
        yy = y1;
   
      } else if (param > 1) {

        xx = x2;
        yy = y2;
      } else {
   
        xx = x1 + param * C;
        yy = y1 + param * D;
      }

      const dx = x - xx;
      const dy = y - yy;
      return Math.sqrt(dx * dx + dy * dy);
    }
   
    //CODE END////////////////////////////////////////



function drawVerticesOnHexagons() {
  const hexagons = document.querySelectorAll('#hexagonGroup polygon');

  hexagons.forEach((hexagon) => {
    const points = hexagon.getAttribute('points').split(' ');

    points.forEach((point) => {
      const [x, y] = point.split(',').map(Number);



console.log(' Vértice (${x}, ${y})');
   

    });
  });
}


//drawVerticesOnHexagons();




function drawRandomVerticesOnHexagons() {
  const hexagons = document.querySelectorAll('#hexagonGroup polygon');
  const totalPoints = 800;
  const pointsToPrint = 30;

  const selectedIndices = new Set();

  while (selectedIndices.size < pointsToPrint) {
    const randomIndex = Math.floor(Math.random() * totalPoints);
    selectedIndices.add(randomIndex);
  }

  hexagons.forEach((hexagon) => {
    const points = hexagon.getAttribute('points').split(' ');

    points.forEach((point, index) => {
      if (selectedIndices.has(index)) {
        const [x, y] = point.split(',').map(Number);



const vertexDot = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
      vertexDot.setAttribute('cx', x);
      vertexDot.setAttribute('cy', y);
      vertexDot.setAttribute('r', '9');
      vertexDot.setAttribute('fill', 'green');

      hexagonGroup.appendChild(vertexDot);




        console.log(`Vértice (${x}, ${y})`);
      }
    });
  });
}




//drawRandomVerticesOnHexagons();






function printRandomValue(min, max) {
  const randomValue = Math.floor(Math.random() * (max - min + 1)) + min;
 return randomValue;
}

// Llama a esta función para imprimir un valor aleatorio entre 1 y 500
//printRandomValue(1, 500);





function getCoordinatesOfVertex(hexagons, targetVertexNumber) {
  let currentVertex = 0;

  for (const hexagon of hexagons) {
    const points = hexagon.getAttribute('points').split(' ');

    for (const point of points) {
      const [x, y] = point.split(',').map(Number);
      currentVertex++;

      if (currentVertex === targetVertexNumber) {
        console.log(`Coordenadas del vértice ${targetVertexNumber}: (${x}, ${y})`);
        return; // Termina la función después de encontrar el vértice deseado
      }
    }
  }

  console.log(`No se encontraron coordenadas para el vértice ${targetVertexNumber}`);
}

// Llamada a la función con el número del vértice deseado (en este caso, 33)
 getCoordinatesOfVertex(document.querySelectorAll('#hexagonGroup polygon'), randomV2);









function drawGreenCirclesOnRandomLocations() {
    const hexagons = document.querySelectorAll('#hexagonGroup polygon');
    const svg = document.querySelector('#hexagonGroup');

    for (let i = 0; i < 30; i++) {
        // Selecciona un hexágono al azar
        const randomHexagon = hexagons[Math.floor(Math.random() * hexagons.length)];
        const points = randomHexagon.getAttribute('points').split(' ');

        // Selecciona dos puntos aleatorios que conformen una línea dentro del hexágono
        const randomPointIndex1 = Math.floor(Math.random() * points.length);
        const randomPointIndex2 = (randomPointIndex1 + 1) % points.length;

        const [x1, y1] = points[randomPointIndex1].split(',').map(Number);
        const [x2, y2] = points[randomPointIndex2].split(',').map(Number);

        // Elije un punto aleatorio entre los dos puntos seleccionados
        const randomT = Math.random();
        const x = x1 + randomT * (x2 - x1);
        const y = y1 + randomT * (y2 - y1);

        // Crea y agrega un círculo verde en el punto seleccionado
        const greenCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        greenCircle.setAttribute('cx', x);
        greenCircle.setAttribute('cy', y);
        greenCircle.setAttribute('r', '6');
        greenCircle.setAttribute('fill', 'green');

        hexagonGroup.appendChild(greenCircle);
    }
}





function drawGreenCirclesOnRandomPoints() {
  const hexagons = document.querySelectorAll('#hexagonGroup polygon');
    const svg = document.querySelector('svg');

    for (let i = 0; i < 30; i++) {
        // Selecciona un hexágono al azar
        const randomHexagon = hexagons[Math.floor(Math.random() * hexagons.length)];
        const points = randomHexagon.getAttribute('points').split(' ');

        // Selecciona dos puntos aleatorios que conformen una línea dentro del hexágono
        const randomPointIndex1 = Math.floor(Math.random() * points.length);
        const randomPointIndex2 = (randomPointIndex1 + 1) % points.length;

        const [x1, y1] = points[randomPointIndex1].split(',').map(Number);
        const [x2, y2] = points[randomPointIndex2].split(',').map(Number);

        // Elije un punto aleatorio entre los dos puntos seleccionados
        const randomT = Math.random();
        const x = x1 + randomT * (x2 - x1);
        const y = y1 + randomT * (y2 - y1);

        // Crea y agrega un círculo verde en el punto seleccionado
        const greenCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        greenCircle.setAttribute('cx', x);
        greenCircle.setAttribute('cy', y);
        greenCircle.setAttribute('r', '8');
        greenCircle.setAttribute('fill', 'green');

        svg.appendChild(greenCircle);
    }
}	



	//////////////////////////////////////////

function detectarColisiones(playerElement) {
    // Obtener las coordenadas del círculo azul
     const blueX = parseFloat(playerElement.getAttribute('cx'));
    const blueY = parseFloat(playerElement.getAttribute('cy'));
    const blueRadius = 9; // Radio del círculo azul (jugador)

    // Iterar sobre los círculos verdes y verificar colisiones con el círculo azul
    document.querySelectorAll('circle[fill="green"]').forEach((greenCircle) => {
        const greenX = parseFloat(greenCircle.getAttribute('cx'));
        const greenY = parseFloat(greenCircle.getAttribute('cy'));
        // Obtener los radios de los círculos
     //   const blueRadius = 9; // Radio del círculo azul
        const greenRadius = parseFloat(greenCircle.getAttribute('r'));
        // Calcular las coordenadas de los cuadros delimitadores
        const blueBoundingBox = {
            x1: blueX - blueRadius,
            y1: blueY - blueRadius,
            x2: blueX + blueRadius,
            y2: blueY + blueRadius };
        const greenBoundingBox = {
            x1: greenX - greenRadius,
            y1: greenY - greenRadius,
            x2: greenX + greenRadius,
            y2: greenY + greenRadius};
        // Verificar la colisión entre los cuadros delimitadores
        if (
            blueBoundingBox.x1 < greenBoundingBox.x2 &&
            blueBoundingBox.x2 > greenBoundingBox.x1 &&
            blueBoundingBox.y1 < greenBoundingBox.y2 &&
            blueBoundingBox.y2 > greenBoundingBox.y1 ) {
            // Eliminar el círculo verde del SVG
            greenCircle.parentNode.removeChild(greenCircle);
            console.log('Colisión detectada. Círculo verde eliminado.');
		socket.emit('greenCircleEaten');}
    });

	//DETECTAR JUGADORES

document.querySelectorAll('circle').forEach((otherCircle) => {

	const playerIdN = otherCircle.getAttribute('id');

if (playerIdN !== socket.id && playerIdN !== null) {

	
        const greenX = parseFloat(otherCircle.getAttribute('cx'));
        const greenY = parseFloat(otherCircle.getAttribute('cy'));
	console.log(`Colision con: (${playerIdN})`); 
	console.log(`SOCKET ID: (${socket.id})`); 

        // Obtener los radios de los círculos
     //   const blueRadius = 9; // Radio del círculo azul
        const greenRadius = parseFloat(otherCircle.getAttribute('r'));
        // Calcular las coordenadas de los cuadros delimitadores
        const blueBoundingBox = {
            x1: blueX - blueRadius,
            y1: blueY - blueRadius,
            x2: blueX + blueRadius,
            y2: blueY + blueRadius };
        const greenBoundingBox = {
            x1: greenX - greenRadius,
            y1: greenY - greenRadius,
            x2: greenX + greenRadius,
            y2: greenY + greenRadius};
        // Verificar la colisión entre los cuadros delimitadores
        if (
            blueBoundingBox.x1 < greenBoundingBox.x2 &&
            blueBoundingBox.x2 > greenBoundingBox.x1 &&
            blueBoundingBox.y1 < greenBoundingBox.y2 &&
            blueBoundingBox.y2 > greenBoundingBox.y1 ) {
            // Eliminar el círculo verde del SVG
          //  otherCircle.parentNode.removeChild(otherCircle);
            console.log('Colisión detectada. Círculo verde eliminado.');
		//socket.emit('greenCircleEaten');
	}

		}
    });



	

    console.log('La detección de colisiones ha terminado.');
}



    /////////////////////////////////////////////////
	
	 
  });
	  
  </script>

	  
</body>
</html>

